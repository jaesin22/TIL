## 정렬 알고리즘

### 버블 정렬

- 버블 정렬이란 앞에서부터 인접한 두 원소를 보면서 앞소가 뒤의 원소보다 클 경우 자리를 바는 것을 반복하면 자연스럽게 제일 큰 것부터 오른쪽에 쌓이게 된다.

- 면접이나 코테에서 버블 정렬에 대한 것을 물어보지는 않을 것. 근데 구현은 할 수 있어야 함.

```# 버블 정렬의 범용성을 높이기 위해 함수로 만듬
def bubbleSort(arr):
    n = len(arr) # 배열의 크기를 측정

    # 배열의 크기만큼 반복
    for i in range(n):

        # 배열의 총 크기에서 i의 값과 1을 뺀 만큼 반복
        for j in range(0, n - i - 1):

            # 만약 현재 인덱스의 값이 다음 인덱스의 값보다 클경우 실행
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j] # 서로 위치를 변환

# 예시 배열
arr = [64, 34, 25, 12, 57, 93, 1, 123]

bubbleSort(arr)

print("[Sorted array is]")
for i in range(len(arr)):
    print("%d " %arr[i], end = "")
```

### Merge Sort

- Merge Sort는 재귀적으로 수열을 나눠 정렬한 후 합치는 정렬법이다.
- 시간복잡도는 O(N log N)
- Merge Sort를 하기 위해서는 먼저 길이가 N, M인 두 정렬된 리스트를 합쳐서 길이 N+M의 정렬된 리스트를 만드는 방법을 알아야 함
- [-9, 1, 6, 8, 12], [-7,7,13,15]라는 이 두 정렬된 리스트가 있다고 가정해보자. 배열 중 가장 작은 원소를 찾기 위해서 모든 배열을 봐야 할까?
- 아니다. 정렬된 리스트이기 때문에 각 배열의 맨 앞 원소만 비교해주면 된다.
- -9와 -7을 비교해보면 -9가 제일 작으니 새로운 배열의 제일 앞에는 -9가 오게 된다는 것을 O(1)에 알 수 있다.
- -9 다음에 오는 수는 첫번째 배열의 1과 두 번째 배열의 -7과 비교한다. 각 리스트에서 앞으로도 쓰인 수는 빼고 나머지 중에서 가장 앞에 있는 것만 계속 채워넣으면 된다는 것을 알 수 있다.
- 연습문제 : BOJ 11728 배열 합치기

- 머지소트는 총 3단계로 요약이 가능하다.

1. 주어진 리스트를 2개로 나눈다.
2. 나눈 리스트 2개를 정렬한다.
3. 정렬된 두 리스트를 합친다.

- 이걸 어떻게 정렬할 수 있을까? 수학적 귀납법을 통해 이해할 수 있다.

1. 1번 도미노가 쓰러진다.
2. k번 도미노가 쓰러진다. k+1번 도미노도 쓰러진다.

- 배열을 예재로 하면?

1. 길이가 1인 리스트를 정렬할 수 있다.
2. 길이가 N인 리스트를 정렬할 수 있다.
3. 길이가 N인 리스트를 정렬할 수 있으면 길이가 2N인 리스트를 정렬할 수 있다.

#### Stable Sort란

- 우선순위가 같은 원소일 때 정렬한 결과가 유일하지 않을 수 있다. 그런 상황에서 같은 원소들끼리는 원래의 순서를 따라가도록 하는 정렬이 Stable Sort이다.
- 즉 첫 번째로 무조건 정렬이 되는 방법은 Stable Sort, 첫 번째로 무조건 정렬이 된다고 보장할 수 없고 두 번째나 세번째로 정렬이 될 수도 있는 방법은 Unstable Sort라고 한다.
- 머지 소트는 Stable Sort이다. 이 성질을 만족시키려면 앞에서 본 것 처럼 앞 리스트에서 현재 보는 원소와 뒤 리스트에서 현재 보는 원소의 우선순위가 같을 때 앞 리스트의 원소를 먼저 보내줘야 한다.
- Stable Sort의 응용
  - 파일 정렬
  * 파일들이 미리 시간의 오름차순으로 나열되어 있을 때 파일을 크기 순으로, 크기가 동일하다면 빨리 생성된 순으로 정렬하고 싶다고 해보자.
  * 이 경우에는 시간을 신경쓰지 말고 그냥 파일의 크기를 기준 삼아서 머지 소트를 수행해서 파일을 크기 순으로, 크기가 동일 하다면 빨리 생성된 순으로 정리할 수 있다.
  * 또한 2차원 좌표들을 x가 작은 순으로, x가 동일하다면 y가 작은 순으로 정렬하고 싶다고 하면 먼저 y의 크기를 기준 삼아서 머지 소트를 수행하고 다음으로 x의 크기를 기준 삼아서 머지 소트를 수행해서 해결할 수 있다.
  * 이렇게 된다면 Stable Sort의 성질 덕분에 일단 x가 작은게 앞으로 올 것이고 x가 같다면 x에 대해 정렬을 수행하기 전에 앞에 있었을 원소, 즉 y가 작은 원소 앞에 오게 될 것이다.
  * 다만 2차원 좌표의 정렬은 이렇게 머지 소트를 두 번 수행하는 것보다는 애초에 머지 소트를 환 번만 해서 정렬하는게 훨씬 낫고 이렇게 하기 위해서는 정렬된 두 배열을 합치는 merge 함수에서 살짝 바꿔주면 된다.

### Quick Sort

- 퀵 소트는 모든 정렬 알고리즘보다 빨라서 각종 라이브러리의 정렬은 대부분 퀵 소트로 이루어져 있다.
- 퀵 소트 동작 방식
  - 퀵 소트에서는 pivot이라고 이름 붙은 원소 하나를 제자리로 보내는 작업을 반복한다.
  - 예제 리스트 [6,-8,1,12,8,3,7,-7]
  - 제일 앞의 원소인 6을 pivot으로 잡아 보자. 6이 아닌 다른 원소를 pivot으로 잡고 싶다고 하면 그냥 6과 자리르 바꾸기만 하면 되기 때문에 pivot은 늘 가장 왼쪽에 위치한다고 생각할 수 있다.
  - pivot을 제자리고 보내고 싶다. 제자리로 보낸다는 뜻은 pivot을 올바른 자리에 넣고 pivot의 왼쪽은 pivot보다 작은 원소가, pivot의 오른쪽은 pivot보다 큰 원소가 오게 하는 것이다
- 퀵소트의 장점 : 추가적인 공간이 필요하지 않다. 또 배열 안에서 자리 바꿈 만으로 처리가 되기 때문에 속도가 빠르다.
- 추가적인 공간을 쓰지 않는 동작
  - 배열 양쪽 끝에 포인터 2개를 두고 적절하게 스왑을 해준다.
  - 에졔 리스트 [6,-8,1,12,8,3,7,-7] l, r 이름을 가진 포인터 2개를 둔다. l은 -6, r은 -7
    1. l은 pivot보다 큰 값이 나올 때 까지 오른쪽으로 이동한다.
    2. r은 pivot보다 작거나 같은 값이 나올 때 까지 왼쪽으로 이동한다.
    3. 그 다음 두 포인터가 가리키는 원소의 값을 스왑한다. 이걸 l과 r이 교차할 때 까지 반복하면 된다.
    4. 동작하다가 r이 l보다 작아진 순간이 오면 pivot과 r을 스왑하면서 알고리즘이 끝난다.
- 퀵소트는 평균적으로 O(log n)이지만 최악의 경우에는 O(N2)가 된다.

### Merge Sort와 Quick Sort의 비교

1. 시간 복잡도는 Merge Sort는 O(N log N), Quick Sort는 평균 O(N log N), 최악 O(N2) 단 평균적으로 Merge Sort보단 빠르다.
2. 추가적으로 필요한 공간(Overhead)는 머지 소트는 O(N), 퀵 소트는 O(1)
3. Stable Sort 여부는 머지 소트는 O, 퀵 소트는 X다.
