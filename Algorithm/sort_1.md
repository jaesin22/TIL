## 정렬 알고리즘

### 버블 정렬

- 버블 정렬이란 앞에서부터 인접한 두 원소를 보면서 앞소가 뒤의 원소보다 클 경우 자리를 바는 것을 반복하면 자연스럽게 제일 큰 것부터 오른쪽에 쌓이게 된다.

- 면접이나 코테에서 버블 정렬에 대한 것을 물어보지는 않을 것. 근데 구현은 할 수 있어야 함.

```# 버블 정렬의 범용성을 높이기 위해 함수로 만듬
def bubbleSort(arr):
    n = len(arr) # 배열의 크기를 측정

    # 배열의 크기만큼 반복
    for i in range(n):

        # 배열의 총 크기에서 i의 값과 1을 뺀 만큼 반복
        for j in range(0, n - i - 1):

            # 만약 현재 인덱스의 값이 다음 인덱스의 값보다 클경우 실행
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j] # 서로 위치를 변환

# 예시 배열
arr = [64, 34, 25, 12, 57, 93, 1, 123]

bubbleSort(arr)

print("[Sorted array is]")
for i in range(len(arr)):
    print("%d " %arr[i], end = "")
```

### Merge Sort

- Merge Sort는 재귀적으로 수열을 나눠 정렬한 후 합치는 정렬법이다.
- 시간복잡도는 O(N log N)
- Merge Sort를 하기 위해서는 먼저 길이가 N, M인 두 정렬된 리스트를 합쳐서 길이 N+M의 정렬된 리스트를 만드는 방법을 알아야 함
- [-9, 1, 6, 8, 12], [-7,7,13,15]라는 이 두 정렬된 리스트가 있다고 가정해보자. 배열 중 가장 작은 원소를 찾기 위해서 모든 배열을 봐야 할까?
- 아니다. 정렬된 리스트이기 때문에 각 배열의 맨 앞 원소만 비교해주면 된다.
- -9와 -7을 비교해보면 -9가 제일 작으니 새로운 배열의 제일 앞에는 -9가 오게 된다는 것을 O(1)에 알 수 있다.
- -9 다음에 오는 수는 첫번째 배열의 1과 두 번째 배열의 -7과 비교한다. 각 리스트에서 앞으로도 쓰인 수는 빼고 나머지 중에서 가장 앞에 있는 것만 계속 채워넣으면 된다는 것을 알 수 있다.

- 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두 번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.
  1. N에서 1을 뺀다.
  2. N을 K로 나눈다.
- 예를 들어 N이 17, K가 4 라고 가정하자. 이 때 1번의 과정을 한 번 수행하면 N은 16이 된다. 이후에 2번의 과정을 두 번 수행하면 N은 1이 됩니다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.
- N과 K가 주어질 때 N이 1이 될 때 까지 1본 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성해보시오.

- 문제 해결 아이디어

  - 주어진 N에 대하여 최대한 많이 나누기를 수행하면 된다.
  - N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있다.

- 정당성 분석

  - 가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있는가?
  - N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있다.
  - 다시 말해 K가 2 이상이기만 한다면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.
    - 또한 N은 항상 1에 도달하게 된다(최적의 해 성립).

- 답안 예시

```python
n, k = map(int, input().split())

result = 0

while True:
    # n이 k로 나누어 떨어지는 수가 될 때까지 빼기
    target = (n // k) * k # 이렇게 한 이유 : n이 k로 나누어 떨어지지 않는다고 했을 때 가장 가까운 k로 나누어 떨어지는 수가 어떤건지 사용할 수 있음
    result += (n - target) # 1을 빼는 연산을 한 횟수
    n = target
    # n이 k보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```

### 예제 문제 3 : 곱하기 혹은 더하기

- 문제 설명

  - 각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하라. 단 +보다 x를 먼저 계산하는 일반적인 방식과 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정한다.
  - 예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2) _ 9) _ 8) \* 4) = 576이다. 또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어진다.

- 문제 해결 아이디어

  - 대부분의 경우 + 보다는 \*가 값을 더 크게 만든다.
    - 예를 들어 5+6 11이고 5\*6은 30이다.
  - 다만 두 수중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기를 수행하는 것이 효율적이다.
  - 따라서 두 수에 대하여 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하며, 두 수가 모두 2 이상인 경우에는 곱하면 된다.

- 답안 예시

```python
data = input()

# 첫 번째 문자를 숫자로 변경하여 대입
result = int(data[0])

for i in range(1, len(data)):
    # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기 보다는 더하기 수행
    num = int(data[i])
    if num <= or result <= 1:
        result += num
    else:
        result =*= num

print(result)
```
