## DP(Dynamic Programming)

- 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제를 해결하는 알고리즘
- DP를 푸는 과정
  1. 테이블 정의하기
  2. 점화식 찾기
  3. 초기값 정하기

### 예제 문제

1. BOJ 1463 : 1로 만들기

   1. 테이블 정의하기

   - D[i]=i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값

   2. 점화식 찾기

   - D[12] = ?
   - 3으로 나누거나(D[12] = D[4] + 1)
   - 2로 나누거나(D[12] = D[6] + 1)
   - 1을 빼거나(D[12] = D[11] + 1)
   - -> D[12] = min(D[4] + 1, D[6] + 1, D[11] + 1)

   - D[k] = ?
   - 3으로 나누어지면 3으로 나누거나(D[k] = D[k/3] + 1)
   - 2로 나누어지면 2로 나누거나(D[k] = D[k/2] + 1)
   - 1을 빼거나(D[k] = D[k-1], + 1), 이들 중에서 최솟값

   3. 초기값 정의하기

   - 점화식에는 무조건 초기값이 있어야 함.
   - 이 문제에서는 D[1]을 0으로 주면 돌아감

2. BOJ 9095번 : 1. 2. 3 더하기

   1. 테이블 정의하기

   - D[i] = i를 1, 2, 3의 합으로 나타내는 방법의 수

   2. 점화식 찾기

   - D[4] = ?
   - 1+1+1+1, 3+1, 2+1+1, 1+2+1 -> 끝에 값이 1로 정해지면 3을 1, 2, 3의 합으로 만드는 방법들을 나열한 후 끝에 +1을 붙이는 상황. 끝에 값이 1인 경우가 4개인 이유는 D[3]이 4이기 때문, 곧 D[3]
   - 1+1+2, 2+2 -> 끝에 값이 2일 때는 2를 1, 2, 3의 합으로 만드는 방법을 나열한 후 끝에 +2를 붙임. D[2]의 값을 가져오면 됨 D[2]
   - 1+3 -> 끝에 값이 3일때는 3을 1, 2, 3의 합으로 만드는 방법을 나열한 후 끝에 +3을 붙임. D[1]
   - 종합하면, D[4] = D[1] + D[2] + D[3]
   - D[i] = D[i-1] + D[i-2] + D[i-3]

   3. 초기값 정하기

   - D[1] = 1, D[2] = 2, D[3] = 4
   - D[i] = D[i-1] + D[i-2] + D[i-3]이니 초기값이 최소 3개는 주어져야 함

3. BOJ 2579 : 계단 오르기

   1. 테이블 정의하기

   - D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단까지 올라섰을 때 점수 합의 최댓값, 단 i번째 계단은 반드시 밟아야 함

   2. 점화식 찾기
